History: ×™×•××Ÿ × ×§×•×“×•×ª (Ledger)
export async function fetchMyHistory(limit = 50, page = 0) {
  const from = page * limit;
  const to = from + limit - 1;

  const { data, error, count } = await supabase
    .from('points_ledger')
    .select('*', { count: 'exact' })
    .order('created_at', { ascending: false })
    .range(from, to);

  if (error) throw error;
  return { rows: data ?? [], total: count ?? 0 };
}

RPC award_points: ×–×™×›×•×™ × ×§×•×“×•×ª ××™×“××¤×•×˜× ×˜×™
type AwardParams = {
  action: string;
  points: number;
  actionKey?: string | null;
  meta?: Record<string, any>;
};

export async function awardPoints({ action, points, actionKey = null, meta = {} }: AwardParams) {
  const { data, error } = await supabase.rpc('award_points', {
    p_action: action,
    p_points: points,
    p_action_key: actionKey,
    p_meta: meta
  });

  // Duplicate action_key (idempotency) ×œ× × ×—×©×‘ ×œ×©×’×™××” ×§×¨×™×˜×™×ª â€” ××¤×©×¨ ×œ×˜×¤×œ ×‘×˜×•×¡×˜ â€œ×›×‘×¨ ×–×•×›×ª×” ×¤×¢×•×œ×” ×–×•â€
  if (error) {
    // ×‘×“"×› conflict ×¢×œ action_key ×™×—×–×•×¨ ××”-DB ×›-23505 ×× ×§×•×¨× ×™×©×™×¨×•×ª ×œ-ledger,
    // ×‘-RPC ×©×œ× ×• ×—×•×–×¨ ×¤×©×•×˜ ×œ×œ× ×©×™× ×•×™. ×›××Ÿ × ×œ×š ×‘×’×™×©×” ×©××¨××” ×©×’×™××” ×¨×§ ×× ×‘×××ª ×‘×¢×™×™×ª×™×ª:
    console.warn('awardPoints error', error);
  }
  // data = [{ total_points, lifetime_points }]
  return (data?.[0]) ?? { total_points: undefined, lifetime_points: undefined };
}

×©×™××•×©×™× × ×¤×•×¦×™×
// ××—×¨×™ ×™×¦×™×¨×ª ×‘×™×§×•×¨×ª:
await awardPoints({
  action: 'review.create',
  points: 50,
  actionKey: `review:${reviewId}`,
  meta: { place_id, review_id: reviewId }
});

// ××—×¨×™ ×”×¢×œ××ª ×ª××•× ×”:
await awardPoints({
  action: 'photo.upload',
  points: 10,
  actionKey: `photo:${photoId}`,
  meta: { place_id, photo_id: photoId }
});

// ×©××™×¨×ª Itinerary:
await awardPoints({
  action: 'itinerary.save',
  points: 10,
  actionKey: `itinerary:${itineraryId}`,
  meta: { itinerary_id: itineraryId }
});

// ×©×™×ª×•×£ Itinerary:
await awardPoints({
  action: 'itinerary.share',
  points: 20,
  actionKey: `share:${itineraryId}:${shareSlug}`,
  meta: { itinerary_id: itineraryId, slug: shareSlug }
});

// Check-in ×™×•××™:
const today = new Date().toISOString().slice(0,10);
await awardPoints({
  action: 'daily.checkin',
  points: 5,
  actionKey: `checkin:${today}`
});

×¢×“×›×•×Ÿ ×”×ª×§×“××•×ª ×”×™×©×’×™× (Progress) + ×¤×ª×™×—×” (Unlock)

××¤×©×¨ ×œ×”×ª×—×™×œ ×¤×©×•×˜ ×‘×¦×“ ×”×œ×§×•×—:

// ×”×’×“×œ×ª progress ×¢×‘×•×¨ ×”×™×©×’×™× ×©×¨×œ×•×•× ×˜×™×™× ×œ×¤×¢×•×œ×”
export async function bumpAchievementsProgressForAction(action: string, bump = 1) {
  // ××©×•×š ××ª ×”×”×™×©×’×™× ×”×¨×œ×•×•× ×˜×™×™× (××¤×©×¨ ×œ×©××•×¨ ×‘×§××©)
  const { data: ach, error } = await supabase
    .from('achievements')
    .select('id, code, criteria_json, points_reward, name')
    .eq('active', true);

  if (error) throw error;

  const targets = (ach ?? []).filter(a =>
    a.criteria_json?.type === 'count' &&
    a.criteria_json?.action === action
  );

  for (const t of targets) {
    // upsert ×œ×©×•×¨×ª user_achievements, ×”×’×“×œ×ª progress ×¢×“ progress_max
    const { data: ua } = await supabase
      .from('user_achievements')
      .select('progress, progress_max, unlocked_at')
      .eq('achievement_id', t.id)
      .single();

    let newProgress = (ua?.progress ?? 0) + bump;
    const progressMax = ua?.progress_max ?? (t.criteria_json?.target ?? 1);
    if (newProgress > progressMax) newProgress = progressMax;

    // ×× ××™×Ÿ ×©×•×¨×” ×§×™×™××ª â€” × ×™×¦×•×¨; ××—×¨×ª × ×¢×“×›×Ÿ
    await supabase
      .from('user_achievements')
      .upsert({
        achievement_id: t.id,
        progress: newProgress,
        progress_max: progressMax,
        // unlocked_at ×™×ª×¢×“×›×Ÿ ××—×¨×™ ×©× ×“×¢ ×©×”×•×©×œ×
      }, { onConflict: 'user_id,achievement_id' });

    // ×× ×”×•×©×œ× â€” × ×¤×ª×— ×‘××“×’' ×•× ×–×›×” ×‘×‘×•× ×•×¡ (×¤×¢× ××—×ª)
    if (!ua?.unlocked_at && newProgress >= progressMax) {
      await supabase
        .from('user_achievements')
        .update({ unlocked_at: new Date().toISOString() })
        .eq('achievement_id', t.id);

      // ×‘×•× ×•×¡ × ×§×•×“×•×ª ×¢×œ unlock (×× ×§×™×™×)
      const bonus = t.points_reward ?? 0;
      if (bonus > 0) {
        await awardPoints({
          action: `achievement.unlock:${t.code}`,
          points: bonus,
          actionKey: `ach_unlock:${t.code}`,
          meta: { achievement_id: t.id }
        });
      }

      // ×›××Ÿ ×ª×¦×™×’ Toast â€œğŸ† ×”×©×’×ª ×‘××“×’' ×—×“×©: t.nameâ€
    }
  }
}


×‘×”××©×š ××¤×©×¨ ×œ×”×¢×‘×™×¨ ××ª ×›×œ ×œ×•×’×™×§×ª ×”-progress ×œÖ¾RPC/DB ×œ×©×§×™×¤×•×ª ×•×‘×™×¦×•×¢×™×, ××‘×œ ×–×” ××¡×¤×§ ×œ×’××¨×™ ×œ×©×œ×‘ ×¨××©×•×Ÿ.