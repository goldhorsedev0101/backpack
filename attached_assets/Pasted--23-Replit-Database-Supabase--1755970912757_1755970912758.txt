🔧 משימה: להעביר את כל הטבלאות (23) מ‑Replit Database ל‑Supabase, כולל סכימה ודאטה, ולהחזיר דוח אימות.

טבלאות להעברה (לבדיקה/אימות ספירות בסוף):
auth/users:        users, sessions
travel/core:       trips, expenses, reviews
gamification:      achievements, userAchievements
social:            placeReviews, reviewVotes, connections,
                   travelBuddyPosts, travelBuddyApplications
chat:              chatRooms, chatRoomMembers, chatMessages
places:            destinations, accommodations, attractions, restaurants
places_meta:       locationReviews, locationSubratings, locationPhotos, locationAncestors

=====================================
שלב 0 — הגדרות וחובות מקדימות
=====================================
1) חייב להיות מוגדר ב-Secrets:
   - DATABASE_URL → חיבור ל-Supabase (מומלץ Transaction Pooler).
2) נסו לאתר את מחרוזת החיבור של Replit Database (Postgres):
   - REPLIT_DB_URL או REPLIT_DATABASE_URL או דומה.
   - אם אין, רשמו "לא נמצא" ועברו למסלול CSV בשלב 5.

בטרמינל הדפיסו (לוג בלבד, ללא סודות גלוים — טשטשו סיסמה):
- הדפיסו שמות משתני סביבה הרלוונטיים: printenv | egrep -i "DB|DATABASE|POSTGRES" | sort
- הדפיסו את DATABASE_URL (עם טשטוש הסיסמה): echo "$DATABASE_URL" | sed -E 's#(://[^:]+:)[^@]+#\1***#'

=====================================
שלב 1 — התקנת כלי Postgres ב-Replit
=====================================
nix-env -iA nixpkgs.postgresql
psql --version
pg_dump --version

=====================================
שלב 2 — מסלול ראשי (אם REPLIT_DB_URL נמצא)
=====================================
אם REPLIT_DB_URL (או דומה) קיים והוא postgresql://...:
1) ודאו הרחבות בסיסיות ב-Supabase (למשל pgcrypto ל-gen_random_uuid):
   psql "$DATABASE_URL" -c "CREATE EXTENSION IF NOT EXISTS pgcrypto;"

2) גיבוי מה-Replit DB:
   # dump בפורמט custom + קובץ SQL טקסטואלי לבקרה
   pg_dump --no-owner --no-privileges --format=custom "$REPLIT_DB_URL" -f replit_db.dump
   pg_dump --no-owner --no-privileges                 "$REPLIT_DB_URL" > replit_db.sql
   ls -lh replit_db.dump replit_db.sql

3) שחזור לסכימה ב-Supabase:
   # סכימה בלבד קודם (DDL)
   pg_dump --no-owner --no-privileges --schema-only "$REPLIT_DB_URL" | psql "$DATABASE_URL"

   # דאטה בלבד (DML)
   pg_dump --no-owner --no-privileges --data-only "$REPLIT_DB_URL" | psql "$DATABASE_URL"

4) אימות בסיסי:
   psql "$DATABASE_URL" -c "\dt public.*"

אם מסלול זה נכשל מחמת אי-נגישות/אין REPLIT_DB_URL — עברו לשלב 5 (CSV).

=====================================
שלב 3 — יישור מפתחות/זהויות (אופציונלי)
=====================================
במידה ויש טבלאות עם SERIAL/IDENTITY/SEQUENCES שנדרשים יישור:
- בצעו ANALYZE ו/או ידיתחו \d+ לטבלאות רלוונטיות.
- אם צריך, תקנו nextval של sequence (דוגמה):
  -- SELECT setval('places_id_seq', (SELECT COALESCE(MAX(id),0) FROM places)+1, false);

(בצעו רק אם מזהים חריגות ב-insert עתידי. אם הכל נטען — אפשר לדלג.)

=====================================
שלב 4 — אימות ספירות לכל 23 הטבלאות
=====================================
psql "$DATABASE_URL" -t -A -c "
WITH t(name) AS (VALUES
 ('users'),('sessions'),
 ('trips'),('expenses'),('reviews'),
 ('achievements'),('userAchievements'),
 ('placeReviews'),('reviewVotes'),('connections'),
 ('travelBuddyPosts'),('travelBuddyApplications'),
 ('chatRooms'),('chatRoomMembers'),('chatMessages'),
 ('destinations'),('accommodations'),('attractions'),('restaurants'),
 ('locationReviews'),('locationSubratings'),('locationPhotos'),('locationAncestors')
)
SELECT name,
       CASE
         WHEN EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema='public' AND table_name=lower(name))
         THEN (SELECT COUNT(*)::text FROM public.\"\"||name||\"\"::regclass)
         ELSE 'MISSING'
       END AS row_count
FROM t
ORDER BY name;
" 2>&1 | sed 's/\"\"//g'

(הערה: בגלל שמות עם אותיות גדולות, אנו משתמשים ב-regclass ומציינים במפורש תוך ציטוט. אם תיתקל בשגיאת regclass, הריצו במקום SELECT COUNT(*) ישיר לכל טבלה הקיימת בפועל.)

=====================================
שלב 5 — Fallback: העברה ב-CSV (אם אין REPLIT_DB_URL)
=====================================
אם אין חיבור Postgres ישיר ל-Replit DB, בצעו:
1) לכל אחת מ-23 הטבלאות, הריצו ב-Replit DB (ממשק/Agent/Query tool) יצוא CSV לקבצים:
   export/<table>.csv  (עם כותרות HEADER)
   (או שלפו SELECT * INTO CSV ידנית).

2) ודאו שקיימת סכימה ב-Supabase (יצרו בטבלאות לפי ההגדרות שלכם — Drizzle/DDL).
   אם יש קונפליקטים ב-constraints, דווחו.

3) טעינת CSV:
   for t in users sessions trips expenses reviews achievements userAchievements \
            placeReviews reviewVotes connections travelBuddyPosts travelBuddyApplications \
            chatRooms chatRoomMembers chatMessages \
            destinations accommodations attractions restaurants \
            locationReviews locationSubratings locationPhotos locationAncestors; do
     psql "$DATABASE_URL" -c "\copy \"$t\" FROM 'export/${t}.csv' CSV HEADER;"
   done

4) אימות \dt וספירות כמו בשלב 4.

=====================================
שלב 6 — דוח מסכם להחזיר בסוף
=====================================
החזירו דוח הכולל:
- 🔗 האם זוהה REPLIT_DB_URL (כן/לא). איזה מסלול בוצע: pg_dump או CSV.
- 📄 רשימת הטבלאות שנמצאו ב-Supabase: הפלט של "\dt public.*" (מקוצר).
- #️⃣ טבלת ספירות לכל 23 הטבלאות (שם + row_count).
- 🧾 קבצי dump שנוצרו (אם בוצע pg_dump): שם + גודל.
- ⚠️ שגיאות/אזהרות (אם היו) + מה דולג/תוקן.
- ✅ מסקנה: "העברה הושלמה" / "נדרשים צעדים נוספים" (פרטו).

הערות:
- השתמשו תמיד באופציות --no-owner/--no-privileges כדי למנוע בעיות הרשאות בסופבייס.
- אל תדפיסו סיסמאות גלויות בדוח.
- אם יש טבלאות עם שמות CamelCase, השאירו ציטוטים כפולים ("TableName") בצד ה-SQL/psql לפי הצורך.
